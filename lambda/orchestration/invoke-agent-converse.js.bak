// Invoke Agent Lambda - Converse API version
// Uses Bedrock Converse API directly instead of Bedrock Agents
// This works with Nova models which have compatibility issues with Bedrock Agents orchestration

const { BedrockRuntimeClient, ConverseCommand } = require('@aws-sdk/client-bedrock-runtime');
const { SSMClient, GetParameterCommand } = require('@aws-sdk/client-ssm');
const { handleMove } = require('../actions/move_handler');
const recallAll = require('../actions/recall_all');
const { acquireExperimentLock, releaseExperimentLock } = require('../shared/db');

const bedrockClient = new BedrockRuntimeClient();
const ssmClient = new SSMClient();

// Cache prompts and pricing
const promptCache = {};
let pricingCache = null;

async function getPrompt(promptVersion) {
  if (promptCache[promptVersion]) {
    return promptCache[promptVersion];
  }
  const command = new GetParameterCommand({
    Name: `/oriole/prompts/${promptVersion}`
  });
  const response = await ssmClient.send(command);
  promptCache[promptVersion] = response.Parameter.Value;
  return promptCache[promptVersion];
}

async function getPricing() {
  if (pricingCache) {
    return pricingCache;
  }
  const command = new GetParameterCommand({
    Name: '/oriole/pricing/models'
  });
  const response = await ssmClient.send(command);
  pricingCache = JSON.parse(response.Parameter.Value);
  return pricingCache;
}

function calculateCost(modelName, inputTokens, outputTokens, pricing) {
  const modelPricing = pricing[modelName];
  if (!modelPricing) {
    console.warn(`No pricing found for model: ${modelName}`);
    return 0;
  }
  const inputCost = (inputTokens / 1000000) * modelPricing.input_per_mtok;
  const outputCost = (outputTokens / 1000000) * modelPricing.output_per_mtok;
  return inputCost + outputCost;
}

// Define tool schemas for Converse API
// These match the actions previously handled by Bedrock Agents action groups
const TOOL_CONFIG = {
  tools: [
    {
      toolSpec: {
        name: "move_north",
        description: "Move one step north (up) in the maze. Returns your new position and what you can see.",
        inputSchema: {
          json: {
            type: "object",
            properties: {
              reasoning: {
                type: "string",
                description: "Your reasoning for why you want to move north"
              }
            },
            required: ["reasoning"]
          }
        }
      }
    },
    {
      toolSpec: {
        name: "move_south",
        description: "Move one step south (down) in the maze. Returns your new position and what you can see.",
        inputSchema: {
          json: {
            type: "object",
            properties: {
              reasoning: {
                type: "string",
                description: "Your reasoning for why you want to move south"
              }
            },
            required: ["reasoning"]
          }
        }
      }
    },
    {
      toolSpec: {
        name: "move_east",
        description: "Move one step east (right) in the maze. Returns your new position and what you can see.",
        inputSchema: {
          json: {
            type: "object",
            properties: {
              reasoning: {
                type: "string",
                description: "Your reasoning for why you want to move east"
              }
            },
            required: ["reasoning"]
          }
        }
      }
    },
    {
      toolSpec: {
        name: "move_west",
        description: "Move one step west (left) in the maze. Returns your new position and what you can see.",
        inputSchema: {
          json: {
            type: "object",
            properties: {
              reasoning: {
                type: "string",
                description: "Your reasoning for why you want to move west"
              }
            },
            required: ["reasoning"]
          }
        }
      }
    },
    {
      toolSpec: {
        name: "recall_all",
        description: "Recall all observations you've made so far in this experiment. Returns a summary of everywhere you've been and what you saw.",
        inputSchema: {
          json: {
            type: "object",
            properties: {
              reasoning: {
                type: "string",
                description: "Your reasoning for why you want to recall your observations"
              }
            },
            required: ["reasoning"]
          }
        }
      }
    }
  ]
};

// Execute a tool call by invoking the appropriate action handler
async function executeTool(toolName, toolInput, experimentId, turnNumber) {
  console.log(`Executing tool: ${toolName}`, toolInput);

  const { reasoning } = toolInput;

  // Acquire lock before executing any action
  await acquireExperimentLock(experimentId);
  console.log(`Acquired lock for experiment ${experimentId}`);

  try {
    let result;

    if (toolName.startsWith('move_')) {
      const direction = toolName.replace('move_', '');
      result = await handleMove(direction, { experimentId, reasoning, turnNumber });
    } else if (toolName === 'recall_all') {
      result = await recallAll.handler({ experimentId, reasoning, turnNumber });
    } else {
      throw new Error(`Unknown tool: ${toolName}`);
    }

    // Parse the response body
    const responseBody = typeof result.body === 'string'
      ? JSON.parse(result.body)
      : result.body;

    return {
      success: result.statusCode === 200,
      data: responseBody
    };

  } finally {
    await releaseExperimentLock(experimentId);
    console.log(`Released lock for experiment ${experimentId}`);
  }
}

// Map model names to Bedrock model IDs
function getModelId(modelName) {
  const modelMap = {
    'claude-3-5-sonnet': 'us.anthropic.claude-3-5-sonnet-20241022-v2:0',
    'claude-3-5-haiku': 'us.anthropic.claude-3-5-haiku-20241022-v1:0',
    'claude-3-haiku': 'anthropic.claude-3-haiku-20240307-v1:0',
    'claude-3-opus': 'anthropic.claude-3-opus-20240229-v1:0',
    'nova-micro': 'us.amazon.nova-micro-v1:0',
    'nova-lite': 'us.amazon.nova-lite-v1:0',
    'nova-pro': 'us.amazon.nova-pro-v1:0'
  };

  return modelMap[modelName] || modelName;
}

exports.handler = async (event) => {
  console.log('Invoke agent event:', JSON.stringify(event, null, 2));

  try {
    const {
      experimentId,
      modelName,
      goalDescription,
      currentX,
      currentY,
      promptVersion = 'v1',
      turnNumber = 1
    } = event;

    console.log(`Starting turn ${turnNumber} for experiment ${experimentId} at (${currentX}, ${currentY}) using ${modelName}`);

    // Get the prompt text
    const promptText = await getPrompt(promptVersion);

    // Construct initial user message
    const initialPrompt = `You are continuing a maze navigation experiment.

Experiment ID: ${experimentId}
Your Current Position: (${currentX}, ${currentY})
Goal: ${goalDescription}

${promptText}`;

    // Initialize conversation
    const messages = [
      {
        role: "user",
        content: [{ text: initialPrompt }]
      }
    ];

    // Get model ID
    const modelId = getModelId(modelName);

    // Inference config - temperature 0 for tool calling
    const inferenceConfig = {
      maxTokens: 2048,
      temperature: 0
    };

    // Track tokens across all turns
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    let conversationComplete = false;
    let finalResponse = '';
    let turnCount = 0;
    const maxTurns = 20; // Prevent infinite loops

    console.log(`Starting Converse API loop with model ${modelId}`);

    // Main conversation loop
    while (!conversationComplete && turnCount < maxTurns) {
      turnCount++;
      console.log(`\n=== Conversation turn ${turnCount} ===`);

      const command = new ConverseCommand({
        modelId,
        messages,
        toolConfig: TOOL_CONFIG,
        inferenceConfig
      });

      const startTime = Date.now();
      const response = await bedrockClient.send(command);
      const elapsed = Date.now() - startTime;

      console.log(`Model response received in ${elapsed}ms`);
      console.log(`Stop reason: ${response.stopReason}`);

      // Track tokens
      if (response.usage) {
        totalInputTokens += response.usage.inputTokens || 0;
        totalOutputTokens += response.usage.outputTokens || 0;
        console.log(`Tokens this turn: ${response.usage.inputTokens} in, ${response.usage.outputTokens} out`);
      }

      // Add assistant message to conversation
      const assistantMessage = response.output.message;
      messages.push(assistantMessage);

      // Process response based on stop reason
      if (response.stopReason === 'tool_use') {
        // Model wants to use tools
        console.log(`Model requested ${assistantMessage.content.length} tool calls`);

        // Execute each tool and collect results
        const toolResults = [];

        for (const block of assistantMessage.content) {
          if (block.toolUse) {
            const { toolUseId, name, input } = block.toolUse;
            console.log(`Executing tool: ${name}`);

            try {
              const result = await executeTool(name, input, experimentId, turnNumber);

              toolResults.push({
                toolResult: {
                  toolUseId,
                  content: [
                    {
                      json: result.data
                    }
                  ],
                  status: result.success ? 'success' : 'error'
                }
              });

              console.log(`Tool ${name} completed:`, result.success ? 'success' : 'error');

            } catch (error) {
              console.error(`Tool ${name} failed:`, error);
              toolResults.push({
                toolResult: {
                  toolUseId,
                  content: [
                    {
                      text: `Error: ${error.message}`
                    }
                  ],
                  status: 'error'
                }
              });
            }
          }
        }

        // Add tool results as next user message
        messages.push({
          role: "user",
          content: toolResults
        });

        console.log(`Added ${toolResults.length} tool results to conversation`);

      } else if (response.stopReason === 'end_turn') {
        // Model is done
        conversationComplete = true;

        // Extract final text response
        for (const block of assistantMessage.content) {
          if (block.text) {
            finalResponse += block.text;
          }
        }

        console.log(`Conversation complete after ${turnCount} turns`);

      } else {
        // Unexpected stop reason
        console.warn(`Unexpected stop reason: ${response.stopReason}`);
        conversationComplete = true;
        finalResponse = `Stopped: ${response.stopReason}`;
      }
    }

    if (turnCount >= maxTurns) {
      console.warn(`Hit maximum turn limit (${maxTurns})`);
      finalResponse = 'Maximum conversation turns reached';
    }

    console.log(`\nTotal tokens: ${totalInputTokens} in, ${totalOutputTokens} out`);

    // Calculate cost
    const pricing = await getPricing();
    const cost = calculateCost(modelName, totalInputTokens, totalOutputTokens, pricing);
    console.log(`Total cost: $${cost.toFixed(6)}`);

    return {
      experimentId,
      agentResponse: finalResponse,
      inputTokens: totalInputTokens,
      outputTokens: totalOutputTokens,
      cost
    };

  } catch (error) {
    console.error('Error in Converse API orchestration:', error);
    throw error;
  }
};
